import { plainToInstance } from 'class-transformer';
import { validate, ValidationError } from 'class-validator';
import { BaseMetricsDto, MetricType, MetricValue } from '../base-metrics.dto';

describe('BaseMetricsDto', () => {
    describe('Type Safety', () => {
        it('should enforce required fields', async () => {
            const dto = new BaseMetricsDto({});
            const errors = await validate(dto);
            expect(errors.length).toBeGreaterThan(0);
            expect(errors.map(e => e.property)).toContain('name');
            expect(errors.map(e => e.property)).toContain('description');
            expect(errors.map(e => e.property)).toContain('value');
        });
        it('should validate metric value structure', async () => {
            const dto = new BaseMetricsDto({
                name: 'request_count',
                description: 'Total number of requests',
                value: new MetricValue({
                    value: 100,
                    type: MetricType.COUNTER
                })
            });
            const errors = await validate(dto);
            expect(errors.length).toBe(0);
        });
        it('should validate metric type enum', async () => {
            const dto = new BaseMetricsDto({
                name: 'request_count',
                description: 'Total number of requests',
                value: new MetricValue({
                    value: 100,
                    type: 'INVALID_TYPE' as MetricType
                })
            });
            const errors = await validate(dto);
            expect(errors.length).toBeGreaterThan(0);
            const valueErrors = errors.find(e => e.property === 'value')?.children || [];
            expect((valueErrors[0] as ValidationError).property).toBe('type');
        });
        it('should validate historical values', async () => {
            const dto = new BaseMetricsDto({
                name: 'request_count',
                description: 'Total number of requests',
                value: new MetricValue({
                    value: 100,
                    type: MetricType.COUNTER
                }),
                history: [
                    new MetricValue({
                        value: 50,
                        type: MetricType.COUNTER,
                        timestamp: new Date().toISOString()
                    }),
                    new MetricValue({
                        value: 75,
                        type: MetricType.COUNTER,
                        timestamp: new Date().toISOString()
                    })
                ]
            });
            const errors = await validate(dto);
            expect(errors.length).toBe(0);
        });
    });
    describe('Default Values', () => {
        it('should set default timestamp in MetricValue', () => {
            const before = new Date();
            const metricValue = new MetricValue({
                value: 100,
                type: MetricType.COUNTER
            });
            const after = new Date();
            const timestamp: number = new Date(metricValue.timestamp);
            expect(timestamp.getTime()).toBeGreaterThanOrEqual(before.getTime());
            expect(timestamp.getTime()).toBeLessThanOrEqual(after.getTime());
            expect(metricValue.timestamp).toMatch(/^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}\.\d{3}Z$/);
        });
    });
    describe('Optional Fields', () => {
        it('should accept valid optional fields', async () => {
            const dto = new BaseMetricsDto({
                name: 'request_count',
                description: 'Total number of requests',
                value: new MetricValue({
                    value: 100,
                    type: MetricType.COUNTER,
                    unit: 'requests/sec'
                }),
                labels: { service: 'api', env: 'prod' },
                history: [
                    new MetricValue({
                        value: 90,
                        type: MetricType.COUNTER,
                        unit: 'requests/sec'
                    })
                ],
                metadata: { lastReset: new Date().toISOString() }
            });
            const errors = await validate(dto);
            expect(errors.length).toBe(0);
        });
        it('should validate labels as object with string values', async () => {
            const dto = new BaseMetricsDto({
                name: 'request_count',
                description: 'Total number of requests',
                value: new MetricValue({
                    value: 100,
                    type: MetricType.COUNTER
                }),
                labels: { valid: 'string', invalid: '123' }
            });
            const errors = await validate(dto);
            expect(errors.length).toBe(0);
        });
    });
    describe('Performance', () => {
        it('should validate within 1ms', async () => {
            const dto = new BaseMetricsDto({
                name: 'request_count',
                description: 'Total number of requests',
                value: new MetricValue({
                    value: 100,
                    type: MetricType.COUNTER
                }),
                history: [
                    new MetricValue({
                        value: 50,
                        type: MetricType.COUNTER,
                        timestamp: new Date().toISOString()
                    }),
                    new MetricValue({
                        value: 75,
                        type: MetricType.COUNTER,
                        timestamp: new Date().toISOString()
                    })
                ]
            });
            const start = process.hrtime();
            await validate(dto);
            const [seconds, nanoseconds] = process.hrtime(start);
            const milliseconds = seconds * 1000 + nanoseconds / 1000000;
            expect(milliseconds).toBeLessThan(1);
        });
        it('should have memory footprint less than 2KB', () => {
            const dto = new BaseMetricsDto({
                name: 'request_count',
                description: 'Total number of requests',
                value: new MetricValue({
                    value: 100,
                    type: MetricType.COUNTER
                }),
                history: [
                    new MetricValue({
                        value: 50,
                        type: MetricType.COUNTER,
                        timestamp: new Date().toISOString()
                    }),
                    new MetricValue({
                        value: 75,
                        type: MetricType.COUNTER,
                        timestamp: new Date().toISOString()
                    })
                ],
                labels: {
                    service: 'api',
                    environment: 'production'
                },
                metadata: {
                    lastUpdate: new Date().toISOString(),
                    source: 'test'
                }
            });
            const size = Buffer.byteLength(JSON.stringify(dto));
            expect(size).toBeLessThan(2048); // 2KB in bytes
        });
    });
    describe('Serialization', () => {
        it('should properly serialize and deserialize', () => {
            const original = new BaseMetricsDto({
                name: 'request_count',
                description: 'Total number of requests',
                value: new MetricValue({
                    value: 100,
                    type: MetricType.COUNTER,
                    unit: 'requests/sec'
                }),
                labels: { service: 'api' },
                history: [
                    new MetricValue({
                        value: 90,
                        type: MetricType.COUNTER,
                        unit: 'requests/sec'
                    })
                ]
            });
            const serialized = JSON.stringify(original);
            const deserialized = plainToInstance(BaseMetricsDto, JSON.parse(serialized));
            expect(deserialized).toBeInstanceOf(BaseMetricsDto);
            expect(deserialized.name).toBe(original.name);
            expect(deserialized.value).toBeInstanceOf(MetricValue);
            expect(deserialized.value.value).toBe(original.value.value);
            expect(deserialized.value.type).toBe(original.value.type);
            expect(deserialized.history?.[0]).toBeInstanceOf(MetricValue);
            expect(deserialized.labels).toEqual(original.labels);
        });
        it('should handle optional fields correctly', () => {
            const original = new BaseMetricsDto({
                name: 'request_count',
                description: 'Total number of requests',
                value: new MetricValue({
                    value: 100,
                    type: MetricType.COUNTER
                })
            });
            const serialized = JSON.stringify(original);
            const deserialized = plainToInstance(BaseMetricsDto, JSON.parse(serialized));
            expect(deserialized.labels).toBeUndefined();
            expect(deserialized.history).toBeUndefined();
            expect(deserialized.metadata).toBeUndefined();
        });
    });
    describe('validation', () => {
        it('should validate a valid metric', () => {
            const metric = new BaseMetricsDto({
                name: 'test_metric',
                description: 'Test metric',
                value: new MetricValue({
                    value: 100,
                    type: MetricType.COUNTER
                })
            });

            expect(metric.isValid()).toBe(true);
        });

        it('should validate metric with labels', () => {
            const metric = new BaseMetricsDto({
                name: 'test_metric',
                description: 'Test metric',
                value: new MetricValue({
                    value: 100,
                    type: MetricType.COUNTER
                }),
                labels: { valid: 'string', invalid: '123' }
            });

            expect(metric.isValid()).toBe(true);
        });

        it('should validate metric with history', () => {
            const metric = new BaseMetricsDto({
                name: 'test_metric',
                description: 'Test metric',
                value: new MetricValue({
                    value: 100,
                    type: MetricType.COUNTER
                }),
                history: [
                    new MetricValue({
                        value: 50,
                        type: MetricType.COUNTER,
                        timestamp: new Date().toISOString()
                    }),
                    new MetricValue({
                        value: 75,
                        type: MetricType.COUNTER,
                        timestamp: new Date().toISOString()
                    })
                ]
            });

            expect(metric.isValid()).toBe(true);
        });

        it('should validate metric with metadata', () => {
            const metric = new BaseMetricsDto({
                name: 'test_metric',
                description: 'Test metric',
                value: new MetricValue({
                    value: 100,
                    type: MetricType.COUNTER
                }),
                metadata: {
                    description: 'Test metric',
                    source: 'test'
                }
            });

            expect(metric.isValid()).toBe(true);
        });
    });

    describe('serialization', () => {
        it('should serialize and deserialize correctly', () => {
            const original = new BaseMetricsDto({
                name: 'test_metric',
                description: 'Test metric',
                value: new MetricValue({
                    value: 100,
                    type: MetricType.COUNTER
                }),
                history: [
                    new MetricValue({
                        value: 50,
                        type: MetricType.COUNTER,
                        timestamp: new Date().toISOString()
                    }),
                    new MetricValue({
                        value: 75,
                        type: MetricType.COUNTER,
                        timestamp: new Date().toISOString()
                    })
                ],
                labels: { env: 'test' }
            });

            const serialized = JSON.stringify(original);
            const deserialized = JSON.parse(serialized);

            expect(deserialized).toBeDefined();
            expect(deserialized.name).toBe(original.name);
            expect(deserialized.value.value).toBe(original.value.value);
            expect(deserialized.value.type).toBe(original.value.type);
            expect(deserialized.history?.[0].value).toBe(original.history?.[0].value);
            expect(deserialized.labels).toEqual(original.labels);
        });

        it('should handle minimal metric data', () => {
            const original = new BaseMetricsDto({
                name: 'minimal_metric',
                description: 'Minimal metric',
                value: new MetricValue({
                    value: 100,
                    type: MetricType.COUNTER
                })
            });

            const serialized = JSON.stringify(original);
            const deserialized = JSON.parse(serialized);

            expect(deserialized).toBeDefined();
            expect(deserialized.name).toBe(original.name);
            expect(deserialized.value.value).toBe(original.value.value);
            expect(deserialized.labels).toBeUndefined();
            expect(deserialized.history).toBeUndefined();
            expect(deserialized.metadata).toBeUndefined();
        });
    });
});
